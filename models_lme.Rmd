---
title: Model Fitting on Abortion Rates
output: html_document
---

```{r setup, echo=FALSE, message=FALSE, warning=FALSE}

knitr::opts_chunk$set(echo = TRUE,
                      warning = FALSE,
                      message = FALSE)

# calling helper file that reads in all packages, data, and homemade functions

source('model_helper_lme.R')

# loading packages & map data here since that's not specifically for modeling &
# this may move to another script eventually

{
  library(maps)
  states <- map_data('state')
  map_df <- usa@data %>% 
    mutate(NAME_1 = str_to_lower(NAME_1)) %>% 
    inner_join(states, by = c('NAME_1' = 'region'))
}

```

## Testing for Spatial Autocorrelation

```{r maps}

# producing 2010 vs 2019 plots for each of our 3 response variables

p1 <- map_df %>% 
  filter(year %in% c(2010, 2019)) %>% 
  ggplot() +
  geom_polygon(aes(long, lat, group = group, fill = abortion_per_1k_births),
               color = 'black') +
  scale_fill_gradient2(high = 'red3') +
  coord_fixed() +
  facet_wrap(~year) +
  labs(title = 'Abortion Rate',
       fill = '') +
  theme(panel.background = element_blank(),
        axis.text = element_blank(),
        axis.line = element_blank(),
        axis.ticks = element_blank(),
        axis.title = element_blank())

# IE ratio

p2 <- map_df %>% 
  filter(year %in% c(2010, 2019)) %>% 
  ggplot() +
  geom_polygon(aes(long, lat, group = group, fill = prop_nonres),
               color = 'black') +
  scale_fill_gradient2(high = 'red3') +
  coord_fixed() +
  facet_wrap(~year) +
  labs(title = 'Nonresident Share of Abortions',
       fill = '') +
  theme(panel.background = element_blank(),
        axis.text = element_blank(),
        axis.line = element_blank(),
        axis.ticks = element_blank(),
        axis.title = element_blank())

# late-early ratio

p3 <- map_df %>% 
  filter(year %in% c(2010, 2019)) %>% 
  ggplot() +
  geom_polygon(aes(long, lat, group = group, fill = prop_late),
               color = 'black') +
  scale_fill_gradient2(high = 'red3') +
  coord_fixed() +
  facet_wrap(~year) +
  labs(title = 'Later-term Share of Abortions',
       fill = '') +
  theme(panel.background = element_blank(),
        axis.text = element_blank(),
        axis.line = element_blank(),
        axis.ticks = element_blank(),
        axis.title = element_blank())

# putting plots together

ggarrange(p1, p2, p3, nrow = 3) %>% 
  annotate_figure(top = text_grob('Spatial structure in outcome variables', 
                                  size = 14))

```

```{r data_corplots}

# creating plots of raw data for latitude, longitude, and year

usa@data %>% 
  select(abortion_per_1k_births, prop_nonres, prop_late,
         latitude, longitude, year) %>% 
  rename(rate = abortion_per_1k_births,
         ie = prop_nonres,
         late_early = prop_late,
         lat = latitude, 
         long = longitude) %>% 
  pivot_longer(rate:late_early, 
               names_to = 'var', values_to = 'data') %>% 
  pivot_longer(lat:year, names_to = 'covariate') %>% 
  mutate(var = fct_relevel(var, 'rate', 'ie', 'late_early')) %>% 
  ggplot(aes(value, data)) +
  geom_point() +
  geom_jitter(width = 0.6, alpha = 0.4) +
  geom_smooth() +
  facet_grid(vars(var), vars(covariate), scales = 'free') +
  theme_bw() +
  labs(title = 'Spatiotemporal trends in outcome variables',
       caption = 'Data are jittered horizontally to distinguish between datapoints occuring in the same locations and years',
       x = '',
       y = 'Outcome variable')

```

```{r global_morans}

# extracting model weight & preparing listws for moran tests

cor_mats <- as.matrix(Initialize(cor_structs[[2]], data = usa@data))
listws <- lapply(cor_mats, mat2listw)
global_moran_results <- list()
m <- 1

# iterating through the variables

for (outcome in list(usa@data$abortion_per_1k_births,
                     usa@data$prop_nonres,
                     usa@data$prop_late)) {
  
  # iterating through each year for each model
  
  for (i in 1:length(2010:2019)) {
  
    # getting the residuals for the current year
    
    this_year <- c(2010:2019)[i]
    this_listw <- listws[[i]]
    this_outcome <- outcome[usa@data$year == this_year]
    
    # now running the moran test
    
    global_moran_results[[m]] <- moran.mc(this_outcome, 
                                   this_listw,
                                   alternative = 'two.sided',
                                   nsim = 9999)
    m <- m+1
  }
}

# putting Moran results in a nice table

do.call(rbind, lapply(global_moran_results, tidy)) %>% 
  mutate(year = rep(2010:2019, times = 3),
         var = rep(c('rate', 'ie', 'late-early'), each = 10),
         significant = p.value < 0.05) %>% 
  select(year, statistic, p.value) %>% 
  kable(booktabs = TRUE,
        #format = 'latex',
        col.names = c('Year', 'I-statistic', 'p-value'),
        caption = "Moran's I-test on outcome variables") %>% 
  pack_rows('Abortion rates', 1, 10) %>%
  pack_rows('Nonresident share of abortions', 11, 20) %>% 
  pack_rows('Later-term share of abortions', 21, 30) %>% 
  column_spec(1:3, width = "7em") %>% 
  row_spec(c(2:3, 5:8, 24), bold = T, color = "black", background = rep("lightyellow"))

```

```{r distributions}

#I want to plot all of the dependent variables & their respective
#transformations to Gaussian

{
  # this requires some data manipulation, which I'm doing below
  
  untransformed <- usa@data %>% 
    select(abortion_per_1k_births,
           prop_nonres,
           prop_late) %>% 
    pivot_longer(everything()) %>% 
    mutate(transformed = FALSE,
           transformation = case_when(name == 'abortion_per_1k_births' ~ 'sqrt(y)',
                                      name == 'prop_nonres' ~ 'log(y)',
                                      name == 'prop_late' ~ 'sqrt(y)')) 
  
  graph_df <- untransformed %>% 
    mutate(value = case_when(name == 'abortion_per_1k_births' ~ sqrt(value),
                                      name == 'prop_nonres' ~ log(value),
                                      name == 'prop_late' ~ sqrt(value)),
           transformed = TRUE) %>% 
    bind_rows(untransformed) %>% 
    mutate(transformation = ifelse(transformed, transformation, 'y')) 
  
  # creating a list of plots in a loop to streamline the code
  
  plots <- list()
  dep_vars <- c('abortion_per_1k_births', 'prop_nonres', 'prop_late')
  facet_labels <- c('Abortion rates', 'Nonresident share of abortions', 'Later-term share of abortions')
  for (i in 1:length(dep_vars)) {
    plots[[i]] <- graph_df %>% 
      filter(name == dep_vars[i]) %>% 
      mutate(transformation = fct_relevel(transformation, 'y')) %>% 
      ggplot(aes(value)) +
      geom_histogram() +
      facet_wrap(~transformation, scales = 'free') +
      labs(title = facet_labels[[i]], x = '', y = '') +
      theme_minimal()
  }
  
  # printing out the plots
  
  ggarrange(plots[[1]], plots[[2]], plots[[3]],
            nrow = 3) %>% 
    annotate_figure(left = textGrob('Count', rot = 90, vjust = 1),
                    bottom = textGrob('Value'),
                    top = text_grob('Dependent variables as approximately Gaussian distributions', 
                                    size = 16)) 

}


```

## Examining models

```{r assigning_models}

# adding our chosen model objects to the environment under easy-to-reference
# names

rate_mod <- fitted_models$rate$raw$best_mod
prop_nonres_mod <- fitted_models$prop_nonres$raw$best_mod
prop_late_mod <- fitted_models$prop_late$raw$best_mod

```

```{r model_comparison}

# running an LRT between the LME and LME with autocorrelation for each of the variables

i <- 1
anova(fitted_models$rate$raw$all_mods$none, fitted_models$rate$raw$all_mods$gaus) %>% 
  bind_rows(anova(fitted_models$prop_nonres$raw$all_mods$none, fitted_models$prop_nonres$raw$all_mods$gaus)) %>% 
  bind_rows(anova(fitted_models$prop_late$raw$all_mods$none, fitted_models$prop_late$raw$all_mods$gaus)) %>%
  as_tibble() %>% 
  mutate(` ` = rep(c('Nonspatial', 'Spatial'), times = 3)) %>% 
  select(-c(call, Model)) %>% 
  select(` `, everything()) %>% 
  mutate(across(c(AIC:logLik, L.Ratio), function(x) round(x, 1))) %>%
  mutate(`p-value` = round(`p-value`, 3)) %>% 
  kable(booktabs = TRUE,
        caption = 'Likelihood Ratio Tests do not support the use of spatial models',
        align=c(rep('c', times = 7))) %>% 
  column_spec(1:7, width = "6em") %>% 
  pack_rows('Abortion Rates (abortions per 1k live births)', 1, 2) %>% 
  pack_rows('Import-Export Ratio', 3, 4) %>% 
  pack_rows('Late-Early Ratio', 5, 6) 

# may eventually use ACF plots because those seem to be used for spatial model
# diagnostics (need to do more research into these though)

#plot(ACF(rate_mod), alpha = 0.05)
#plot(ACF(prop_nonres_mod), alpha = 0.05)
#plot(ACF(prop_late_mod), alpha = 0.05)

```

```{r display_all_coefs}

# getting column names for kable output... need to do it like this so I can get
# the names to cover multiple lines

names_spaced <- c(
  'Variable',
  'Rate model: Change in the square root of the abortion rate',
  'Nonresident share model: Change in the natural log of the nonresident abortion rate',
  'Later-term share model: Change in the square root of the later-term abortion rate'
  )

get_summary_df <- function (mod) {
  return(rownames_to_column(as.data.frame(summary(mod)$tTable), 'term'))
}

big_coef_df <- mutate(get_summary_df(rate_mod), dep = 'rate') %>% 
  bind_rows(mutate(get_summary_df(prop_nonres_mod), dep = 'nonres'),
            mutate(get_summary_df(prop_late_mod), dep = 'late')) %>% 
  clean_names() %>% 
  mutate(ci = paste0('(', round(value-qnorm(0.975)*std_error, 3), 
                     ', ', round(value+qnorm(0.975)*std_error, 3), ')'),
         value = round(value, 3)) %>% 
  mutate(value = ifelse(p_value < 0.05, paste0(value, '*'), value),
         pr_z = round(p_value, 3),
         value = paste(value, ci)) %>% 
  select(term, value, dep) %>% 
  pivot_wider(names_from = dep, values_from = value) %>% 
  mutate(term = str_remove_all(term, 'within_between')) %>% 
  mutate(term = fct_relevel(term,
                            '(Intercept)',
                            'surrounding_score', 
                            'within_score', 
                            'surrounding_score:within_score',
                            'abortions', 'dem_2party', 'hh_income', 'pct_bachelors',
                            'prop_hisp', 'prop_nonwhite')) %>% 
  arrange(term)

big_coef_df %>% 
  kable(booktabs = TRUE,
        #format = 'latex',
        col.names = names_spaced,
        caption = 'Fixed Effects Coefficients for Linear Mixed-Effects Models',
        align = c('l', rep('c', times = 3))) %>% 
  pack_rows('Policy environment', 2, 4) %>%
  pack_rows('Control variables', 5, 10) %>% 
  column_spec(1:4, width = "15em") %>% 
  row_spec(c(2, 4), bold = T, color = "black", background = "lightyellow")

```

```{r temporal_effects}

# creating function to get year random effects from model

get_yr_random <- function(mod) {
  ranef(mod) %>% 
    as.data.frame() %>% 
    rownames_to_column('year') %>% 
    rename(intercept = `(Intercept)`) %>% 
    select(year, intercept)
}

# doing this for my 3 models & displaying values together

temporal_df <- mutate(get_yr_random(rate_mod), mod = 'rate') %>% 
  bind_rows(mutate(get_yr_random(prop_nonres_mod), mod = 'prop_nonres'), 
            mutate(get_yr_random(prop_late_mod), mod = 'prop_late')) 
temporal_df %>% 
  select(-mod) %>% 
  kable(booktabs = TRUE,
        col.names = c('Year', 'Intercept'),
        caption = 'Random Effects of Year on the Outcome Variables') %>% 
  column_spec(1:2, width = "8em") %>% 
  pack_rows('Abortion Rate', 1, 10) %>% 
  pack_rows('Nonresident Share of Abortions', 11, 20) %>% 
  pack_rows('Later-term Share of Abortions', 21, 30)

# visualizing in a plot

temporal_df %>% 
  mutate(mod = fct_relevel(mod, 'rate', 'prop_nonres', 'prop_late')) %>% 
  ggplot(aes(year, intercept)) +
  geom_point() +
  facet_wrap(~mod, scales = 'free_y', nrow = 3) +
  geom_hline(yintercept = 0, color = 'red', linetype = 'dotted') +
  geom_smooth() +
  theme_bw() +
  labs(title = 'Temporal random intercepts',
       x = '',
       y = 'Random intercepts')

```

## Model diagnostics

```{r all_residual_morans}

# extracting model weight & preparing listws for moran tests

cor_mats <- as.matrix(Initialize(cor_structs[[2]], data = usa@data))
listws <- lapply(cor_mats, mat2listw)
moran_results <- list()
m <- 1

# iterating through the models

for (mod in list(rate_mod, prop_nonres_mod, prop_late_mod)) {
  
  # iterating through each year for each model
  
  for (i in 1:length(2010:2019)) {
  
    # getting the residuals for the current year
    
    this_year <- c(2010:2019)[i]
    this_listw <- listws[[i]]
    this_resid <- residuals(mod)[names(residuals(mod)) == as.character(this_year)]
    
    # now running the moran test
    
    moran_results[[m]] <- moran.mc(this_resid, 
                                   this_listw,
                                   alternative = 'two.sided',
                                   nsim = 9999)
    m <- m+1
  }
}

# putting Moran results in a nice table

do.call(rbind, lapply(moran_results, tidy)) %>% 
  mutate(year = rep(2010:2019, times = 3),
         var = rep(c('rate', 'ie', 'late-early'), each = 10),
         significant = p.value < 0.05) %>% 
  select(year, statistic, p.value) %>% 
  kable(booktabs = TRUE,
        #format = 'latex',
        col.names = c('Year', 'I-statistic', 'p-value'),
        caption = "Moran's I-test on model residuals") %>% 
  pack_rows('Abortion rates', 1, 10) %>%
  pack_rows('Nonresident share of abortions', 11, 20) %>% 
  pack_rows('Later-term share of abortions', 21, 30) %>% 
  column_spec(1:3, width = "7em") %>% 
  row_spec(c(3, 11), bold = T, color = "black", background = rep("lightyellow"))

```

```{r resid_maps}

# I also want to map model residuals by year

states <- map_data('state')
for (y in 2010:2019) {
  p <- usa@data %>% 
    mutate(rate_resids = residuals(rate_mod),
           ie_resids = residuals(prop_nonres_mod),
           late_early_resids = residuals(prop_late_mod),
           NAME_1 = str_to_lower(NAME_1)) %>% 
    inner_join(states, by = c('NAME_1' = 'region')) %>%
    filter(year == y) %>% 
    ggplot() +
    geom_polygon(aes(long, lat, group=group, fill = rate_resids),
                 color = 'black') +
    facet_wrap(~year) +
    coord_fixed() +
    labs(title = "Model residuals") +
    theme(panel.background = element_blank(),
          axis.text = element_blank(),
          axis.line = element_blank(),
          axis.ticks = element_blank(),
          axis.title = element_blank())
  print(p)
}

# # making ggplot animations
# library(gganimate)
# data_resids %>%
#   ggplot() +
#   geom_polygon(aes(long, lat, group=group, fill = rate_resids),
#                color = 'black') +
#   transition_states(year) +
#   coord_fixed() +
#   labs(title = "Within-state policy scores in {closest_state}") +
#   theme(panel.background = element_blank(),
#         axis.text = element_blank(),
#         axis.line = element_blank(),
#         axis.ticks = element_blank(),
#         axis.title = element_blank())

```

```{r model_plots}

# generating diagnostic plots for each model

models <- list(rate_mod, prop_nonres_mod, prop_late_mod)
plots <- list()
for (i in 1:length(models)) {
  
  # fitted vs residuals plot
  
  resid_vs_fit <- tibble(fit = fitted(models[[i]]), 
                       resid = residuals(models[[i]])) %>% 
  ggplot(aes(fit, resid)) +
  geom_point() +
  geom_hline(yintercept = 0,
             color = 'red',
             linetype = 'dashed') +
  theme_minimal() +
  labs(title = 'Residuals vs. fitted values',
       x = 'Fitted values',
       y = 'Residuals')
  
  # creating qqplot now
  
  plot_data <- tibble(fit = fitted(models[[i]]), 
                      resid = residuals(models[[i]])) 
  qqplot <- plot_data %>% 
    ggplot(aes(sample = resid)) +
    stat_qq() +
    stat_qq_line(col = 'red') +
    theme_minimal() +
    labs(title = 'QQ-plot for normality of residuals',
         x = 'Theoretical quantiles',
         y = 'Sample quantiles')
  
  plots[[i]] <- annotate_figure(ggarrange(resid_vs_fit, qqplot),
                                top = text_grob(paste('Diagnosic plots for', outcome_vars[[i]]),size = 14))
}

plots

```

```{r residual_corrplots}

# decreasing semivariograms... what does this mean?

plot(Variogram(rate_mod),
     main = 'Semivariogram for rate_mod')
plot(Variogram(prop_nonres_mod),
     main = 'Semivariogram for prop_nonres_mod')
plot(Variogram(prop_late_mod),
     main = 'Semivariogram for prop_late_mod')

plot(Variogram(usa@data$prop_nonres, cor_structs[[2]]))

# creating plots of residuals for latitude, longitude, and year

residual_df <- tibble(rate_resid = residuals(rate_mod),
                      ie_resid = residuals(prop_nonres_mod),
                      late_early_resid = residuals(prop_late_mod),
                      lat = usa@data$latitude,
                      long = usa@data$longitude,
                      year = usa@data$year)

residual_df %>% 
  pivot_longer(rate_resid:late_early_resid, names_to = 'var', values_to = 'resid') %>% 
  mutate(var = str_remove_all(var, '_resid')) %>% 
  pivot_longer(lat:year, names_to = 'covariate') %>% 
  mutate(var = fct_relevel(var, 'rate', 'ie', 'late_early')) %>%
  ggplot(aes(value, resid)) +
  geom_point() +
  geom_jitter(width = 0.6, alpha = 0.4) +
  facet_grid(vars(var), vars(covariate), scales = 'free') +
  geom_hline(yintercept = 0, color = 'red') +
  geom_smooth()+
  theme_bw() +
  labs(title = 'Model residuals as a function of location and time') +
  scale_y_continuous(limits = egg::symmetric_range) 

```

