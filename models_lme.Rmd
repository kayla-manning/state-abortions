---
title: Model Fitting on Abortion Rates
output: html_document
---

```{r setup, echo=FALSE, message=FALSE, warning=FALSE}

knitr::opts_chunk$set(echo = TRUE,
                      warning = FALSE,
                      message = FALSE)

# calling helper file that reads in all packages, data, and homemade functions

source('model_helper_lme.R')

# loading packages & map data here since that's not specifically for modeling &
# this may move to another script eventually

{
  library(maps)
  states <- map_data('state')
  map_df <- usa@data %>% 
    mutate(NAME_1 = str_to_lower(NAME_1)) %>% 
    inner_join(states, by = c('NAME_1' = 'region'))
}

```

## Testing for Spatial Autocorrelation

```{r maps}

# producing 2010 vs 2019 plots for each of our 3 response variables

p1 <- map_df %>% 
  filter(year %in% c(2010, 2019)) %>% 
  ggplot() +
  geom_polygon(aes(long, lat, group = group, fill = abortion_per_1k_births),
               color = 'black') +
  scale_fill_gradient2(high = 'red3') +
  coord_fixed() +
  facet_wrap(~year) +
  labs(title = 'Abortions per 1k births',
       fill = '') +
  theme(panel.background = element_blank(),
        axis.text = element_blank(),
        axis.line = element_blank(),
        axis.ticks = element_blank(),
        axis.title = element_blank())

# IE ratio

p2 <- map_df %>% 
  filter(year %in% c(2010, 2019)) %>% 
  ggplot() +
  geom_polygon(aes(long, lat, group = group, fill = ie_ratio),
               color = 'black') +
  scale_fill_gradient2(high = 'red3') +
  coord_fixed() +
  facet_wrap(~year) +
  labs(title = 'Import-export ratio',
       fill = '') +
  theme(panel.background = element_blank(),
        axis.text = element_blank(),
        axis.line = element_blank(),
        axis.ticks = element_blank(),
        axis.title = element_blank())

# late-early ratio

p3 <- map_df %>% 
  filter(year %in% c(2010, 2019)) %>% 
  ggplot() +
  geom_polygon(aes(long, lat, group = group, fill = late_to_early),
               color = 'black') +
  scale_fill_gradient2(high = 'red3') +
  coord_fixed() +
  facet_wrap(~year) +
  labs(title = 'Late-early ratio',
       fill = '') +
  theme(panel.background = element_blank(),
        axis.text = element_blank(),
        axis.line = element_blank(),
        axis.ticks = element_blank(),
        axis.title = element_blank())

# putting plots together

ggarrange(p1, p2, p3, nrow = 3) %>% 
  annotate_figure(top = text_grob('Spatial structure in outcome variables', 
                                  size = 14))

```

```{r data_corplots}

# creating plots of residuals for latitude, longitude, and year

usa@data %>% 
  select(abortion_per_1k_births, ie_ratio, late_to_early,
         latitude, longitude, year) %>% 
  rename(rate = abortion_per_1k_births,
         ie = ie_ratio,
         late_early = late_to_early,
         lat = latitude, 
         long = longitude) %>% 
  pivot_longer(rate:late_early, 
               names_to = 'var', values_to = 'data') %>% 
  pivot_longer(lat:year, names_to = 'covariate') %>% 
  mutate(var = fct_relevel(var, 'rate', 'ie', 'late_early')) %>% 
  ggplot(aes(value, data)) +
  geom_point() +
  geom_jitter(width = 0.6, alpha = 0.4) +
  geom_smooth() +
  facet_grid(vars(var), vars(covariate), scales = 'free') +
  theme_bw() +
  labs(title = 'Spatiotemporal trends in outcome variables',
       caption = 'Data are jittered horizontally to distinguish between datapoints occuring in the same locations and years',
       x = '',
       y = 'Outcome variable')

```

```{r global_moran}

# creating a list object to store moran tests in

{
  weights_list <- list(weights.contig.W, weights.inv.dist, weights.inv.dist2)
  outcome_list <- list(usa@data$abortion_per_1k_births,
                       usa@data$ie_ratio,
                       usa@data$late_to_early)
  moran_list <- list()
  i <- 1
  
  # iterating through and storing as a list
  for (outcome in outcome_list) {
    for (weight in weights_list) {
      moran_list[[i]] <- moran.mc(outcome,
                                  listw = weight,
                                  nsim = 9999,
                                  alternative = 'two.sided')
      i <- i + 1
    }
  }
}


do.call(rbind, lapply(moran_list, tidy)) %>% 
  mutate(var = rep(c('rate', 'ie', 'late_early'), each = 3),
         neighbors = rep(c('contig', 'invdist', 'invdist2'), times = 3)) %>% 
  select(neighbors, statistic, p.value) %>% 
  kable(booktabs = TRUE,
        col.names = c('Neighborhoods', 'I-statistic', 'p-value'),
        caption = "Moran's I-test on outcome variables") %>% 
  pack_rows('Abortion rates', 1, 3) %>% 
  pack_rows('Import-export ratio', 4, 6) %>% 
  pack_rows('Late-early ratio', 7, 9)

# doing the same thing but with the model residuals

residual_morans <- lapply(list(rate_sar, ie_sar, late_early_sar), 
                          function (x) moran.mc(residuals(x), 
                                                weights.inv.dist,
                                                alternative = 'two.sided',
                                                nsim = 9999))
do.call(rbind, lapply(residual_morans, tidy)) %>% 
  mutate(var = c('rate', 'ie', 'late_early')) %>% 
  select(var, statistic, p.value) %>% 
  kable(booktabs = TRUE,
        caption = "Moran's I-test on SAR model residuals")

```

```{r distributions}

#I want to plot all of the dependent variables & their respective
#transformations to Gaussian

{
  # this requires some data manipulation, which I'm doing below
  
  untransformed <- usa@data %>% 
    select(abortion_per_1k_births,
           ie_ratio,
           late_to_early) %>% 
    pivot_longer(everything()) %>% 
    mutate(transformed = FALSE,
           transformation = case_when(name == 'abortion_per_1k_births' ~ 'none',
                                      name == 'ie_ratio' ~ 'log(x)',
                                      name == 'late_to_early' ~ 'sqrt(x)')) 
  
  graph_df <- untransformed %>% 
    mutate(value = case_when(name == 'abortion_per_1k_births' ~ value,
                                      name == 'ie_ratio' ~ log(value),
                                      name == 'late_to_early' ~ sqrt(value)),
           transformed = TRUE) %>% 
    bind_rows(untransformed) %>% 
    mutate(transformation = ifelse(transformed, transformation, 'untransformed')) 
  
  # creating a list of plots in a loop to streamline the code
  
  plots <- list()
  dep_vars <- c('abortion_per_1k_births', 'ie_ratio', 'late_to_early')
  for (i in 1:length(dep_vars)) {
    plots[[i]] <- graph_df %>% 
      filter(name == dep_vars[i]) %>% 
      mutate(transformation = fct_relevel(transformation, 'untransformed')) %>% 
      ggplot(aes(value)) +
      geom_histogram() +
      facet_wrap(~transformation, scales = 'free') +
      labs(title = dep_vars[[i]], x = '', y = '') +
      theme_minimal()
  }
  
  # printing out the plots
  
  ggarrange(plots[[1]], plots[[2]], plots[[3]]) %>% 
    annotate_figure(left = textGrob('Count', rot = 90, vjust = 1),
                    bottom = textGrob('Value'),
                    top = text_grob('Dependent variables as approximately Gaussian distributions', 
                                    size = 16)) 

}


```

## Examining models

```{r model_comparison}

# getting df ready for model comparison (only the raw models)

tibble(outcome = rep(c('rate', 'ie', 'late-early'),
                     each = length(names(fitted_models$rate$raw$AICs))),
       spatial_cor = rep(names(fitted_models$rate$raw$AICs),
                         times = 3),
       AICs = c(unlist(fitted_models$rate$raw$AICs),
                unlist(fitted_models$ie$raw$AICs),
                unlist(fitted_models$late_early$raw$AICs))) %>% 
  select(-outcome) %>% 
  kable(booktabs = TRUE,
        col.names = c('Correlation Structure', 'AIC'),
        caption = 'AICs for nonspatial vs. spatial models') %>% 
  pack_rows('Abortion Rates (abortions per 1k live births)', 1, length(names(fitted_models$rate$raw$AICs))) %>% 
  pack_rows('Import-Export Ratio', 
            length(names(fitted_models$rate$raw$AICs))+1, 
            2*length(names(fitted_models$rate$raw$AICs))) %>% 
  pack_rows('Late-Early Ratio', 
            2*length(names(fitted_models$rate$raw$AICs))+1,
            3*length(names(fitted_models$rate$raw$AICs))) %>% 
  row_spec(seq(2, 6, 2), bold = T, color = "black", background = "lightyellow")

# may eventually produce a grouped table with all model AICs

single_fit_df <- function (mod) {
  
  mysum <- summary(mod)
  output <- tibble(measure = c('AIC', 'BIC', 'logLik'),
                   value = c(mysum$AIC, mysum$BIC, mysum$logLik))
  return(output)
}

both_fit_df <- function(mod_list) {
  output <- do.call(bind_rows, lapply(mod_list, single_fit_df)) %>% 
    mutate(autocor = rep(c('none', 'gaus'), each = 3))
  return(output)
}

# displaying statistics in a table

mutate(both_fit_df(fitted_models$rate$raw$all_mods), outcome = 'rate') %>% 
  bind_rows(mutate(both_fit_df(fitted_models$ie$raw$all_mods), outcome = 'ie'),
            mutate(both_fit_df(fitted_models$late_early$raw$all_mods), outcome = 'late-early')) %>% 
  pivot_wider(names_from = measure, values_from = value) %>% 
  select(-outcome) %>% 
  rename(`Correlation Structure` = autocor) %>% 
  mutate(across(AIC:logLik, function(x) round(x, 3))) %>% 
  kable(booktabs = TRUE,
        caption = 'Assessing fit of spatial vs. non-spatial models') %>% 
  column_spec(1:4, width = "10em") %>% 
  row_spec(seq(2, 6, 2), bold = T, color = "black", background = "lightyellow") %>% 
  pack_rows('Abortion Rates (abortions per 1k live births)', 1, 2) %>% 
  pack_rows('Import-Export Ratio', 3, 4) %>% 
  pack_rows('Late-Early Ratio', 5, 6)

# now running an LRT between the LME and LME with autocorrelation for each of the variables

i <- 1
anova(fitted_models$rate$raw$all_mods$none, rate_mod) %>% 
  bind_rows(anova(fitted_models$ie$raw$all_mods$none, ie_mod)) %>% 
  bind_rows(anova(fitted_models$late_early$raw$all_mods$none, late_early_mod)) %>% 
  as_tibble() %>% 
  mutate(`Correlation Structure` = rep(c('none', 'gaus'), times = 3)) %>% 
  select(-c(call, Model)) %>% 
  select(`Correlation Structure`, everything()) %>% 
  kable(booktabs = TRUE,
        caption = 'Likelihood Ratio Tests support the use of spatiotemporal models') %>% 
  column_spec(1:4, width = "5em") %>% 
  row_spec(seq(2, 6, 2), bold = T, color = "black", background = "lightyellow") %>% 
  pack_rows('Abortion Rates (abortions per 1k live births)', 1, 2) %>% 
  pack_rows('Import-Export Ratio', 3, 4) %>% 
  pack_rows('Late-Early Ratio', 5, 6) 


plot(ACF(rate_mod), alpha = 0.05)
plot(ACF(ie_mod), alpha = 0.05)
plot(ACF(late_early_mod), alpha = 0.05)

```

```{r assigning_models}

# adding our chosen model objects to the environment under easy-to-reference
# names

rate_mod <- fitted_models$rate$raw$best_mod
ie_mod <- fitted_models$ie$raw$best_mod
late_early_mod <- fitted_models$late_early$raw$best_mod

```

```{r display_all_coefs}

# getting column names for kable output... need to do it like this so I can get
# the names to cover multiple lines

names_spaced <- c(
  'Variable',
  'Rate model: Change in abortions per 1k births',
  'IE model: Multiplicative change in import-export ratio',
  'Late-early model: Change in the square root of the late-early ratio'
  )

get_summary_df <- function (mod) {
  return(rownames_to_column(as.data.frame(summary(mod)$tTable), 'term'))
}

big_coef_df <- mutate(get_summary_df(rate_mod), dep = 'rate') %>% 
  bind_rows(mutate(get_summary_df(ie_mod), dep = 'ie'),
            mutate(get_summary_df(late_early_mod), dep = 'late-early')) %>% 
  clean_names() %>% 
  mutate(ci = ifelse(dep != 'ie',
                     paste0('(', round(value-qnorm(0.975)*std_error, 3), 
                            ', ', round(value+qnorm(0.975)*std_error, 3), ')'),
                     paste0('(', round(exp(value-qnorm(0.975)*std_error), 3), 
                            ', ', round(exp(value+qnorm(0.975)*std_error), 3), ')')),
         value = ifelse(dep == 'ie', exp(value), value),
         value = round(value, 3)) %>% 
  mutate(value = ifelse(p_value < 0.05, paste0(value, '*'), value),
         pr_z = round(p_value, 3),
         value = paste(value, ci)) %>% 
  select(term, value, dep) %>% 
  pivot_wider(names_from = dep, values_from = value) %>% 
  mutate(term = str_remove_all(term, 'within_between')) %>% 
  mutate(term = str_remove_all(term, fixed('as.factor(year)'))) %>% 
  mutate(term = fct_relevel(term,
                            '(Intercept)',
                            'surrounding_score', 
                            'within_score', 
                            'surrounding_score:within_score',
                            'abortions', 'dem_2party', 'hh_income', 'pct_bachelors',
                            'prop_hisp', 'prop_nonwhite')) %>% 
  arrange(term)

big_coef_df %>% 
  kable(booktabs = TRUE,
        #format = 'latex',
        col.names = names_spaced,
        caption = 'Fixed Effects for Linear Mixed Effects Models with Spatiotemporal Autocorrelation') %>% 
  pack_rows('Policy environment', 2, 4) %>%
  pack_rows('Control variables', 5, 10) %>% 
  column_spec(1:4, width = "10em") %>% 
  row_spec(c(2, 4), bold = T, color = "black", background = "lightyellow")

```

```{r temporal_effects}

# creating function to get year random effects from model

get_yr_random <- function(mod) {
  coef(mod) %>% 
    as.data.frame() %>% 
    rownames_to_column('year') %>% 
    rename(intercept = `(Intercept)`) %>% 
    select(year, intercept, latitude, longitude)
}

# doing this for my 3 models & displaying values together

mutate(get_yr_random(rate_mod), mod = 'rate') %>% 
  bind_rows(mutate(get_yr_random(ie_mod), mod = 'ie'), 
            mutate(get_yr_random(late_early_mod), mod = 'late_early')) %>% 
  select(-mod) %>% 
  kable(booktabs = TRUE,
        col.names = c('Year', 'Intercept', 'Latitude', 'Longitude'),
        caption = 'Random Effects of Year on the Outcome Variables') %>% 
  column_spec(1:4, width = "8em") %>% 
  pack_rows('Abortion Rates (abortions per 1k live births)', 1, 10) %>% 
  pack_rows('Import-Export Ratio', 11, 20) %>% 
  pack_rows('Late-Early Ratio', 21, 30)

```


## Model diagnostics

```{r all_residual_morans}

# running bootstrapped Moran test with the model residuals

weight_matrices <- list(weights.contig.W, weights.inv.dist, weights.inv.dist2)

# running a moran test on residuals for each weight scheme

moran_df <- tibble()
for (w in weight_matrices) {
  
  residual_morans <- lapply(list(rate_mod, ie_mod, late_early_mod), 
                          function (x) moran.mc(residuals(x), 
                                                w,
                                                alternative = 'two.sided',
                                                nsim = 999))
  
  add_df <- do.call(rbind, lapply(residual_morans, tidy)) %>% 
                          mutate(var = c('rate', 'ie', 'late_early')) %>% 
                          select(var, statistic, p.value)
  
  moran_df <- bind_rows(moran_df, add_df) 
  
}

# formatting for output

moran_df %>% 
  kable(booktabs = TRUE,
        caption = "Moran's I-test on spatial model residuals",
        col.names = c('Outcome', 'I-statistic', 'p')) %>% 
  column_spec(1:3, width = "10em") %>% 
  pack_rows('Contiguous neighborhoods', 1, 3) %>% 
  pack_rows('Inverse-distance neighborhoods', 4, 6) %>% 
  pack_rows('Inverse-squared-distance neighborhoods', 7, 9)

```

```{r model_plots}

# generating diagnostic plots for each model

models <- list(rate_mod, ie_mod, late_early_mod)
plots <- list()
for (i in 1:length(models)) {
  
  # fitted vs residuals plot
  
  resid_vs_fit <- tibble(fit = fitted(models[[i]]), 
                       resid = residuals(models[[i]])) %>% 
  ggplot(aes(fit, resid)) +
  geom_point() +
  geom_hline(yintercept = 0,
             color = 'red',
             linetype = 'dashed') +
  theme_minimal() +
  labs(title = 'Residuals vs. fitted values',
       x = 'Fitted values',
       y = 'Residuals')
  
  # creating qqplot now
  
  plot_data <- tibble(fit = fitted(models[[i]]), 
                      resid = residuals(models[[i]])) 
  qqplot <- plot_data %>% 
    ggplot(aes(sample = resid)) +
    stat_qq() +
    stat_qq_line(col = 'red') +
    theme_minimal() +
    labs(title = 'QQ-plot for normality of residuals',
         x = 'Theoretical quantiles',
         y = 'Sample quantiles')
  
  plots[[i]] <- annotate_figure(ggarrange(resid_vs_fit, qqplot),
                                top = text_grob(paste('Diagnosic plots for', outcome_vars[[i]]),size = 14))
}

plots[[1]]

```

```{r residual_corrplots}

for (m in models) {
  print(plot(Variogram(m)))
}

# creating plots of residuals for latitude, longitude, and year

residual_df <- tibble(rate_resid = residuals(rate_mod),
                      ie_resid = residuals(ie_mod),
                      late_early_resid = residuals(late_early_mod),
                      lat = usa@data$latitude,
                      long = usa@data$longitude,
                      year = usa@data$year)

residual_df %>% 
  pivot_longer(rate_resid:late_early_resid, names_to = 'var', values_to = 'resid') %>% 
  mutate(var = str_remove_all(var, '_resid')) %>% 
  pivot_longer(lat:year, names_to = 'covariate') %>% 
  mutate(var = fct_relevel(var, 'rate', 'ie', 'late_early')) %>% 
  ggplot(aes(value, resid)) +
  geom_point() +
  facet_grid(vars(var), vars(covariate), scales = 'free') +
  geom_hline(yintercept = 0, color = 'red') +
  theme_bw() +
  labs(title = 'Model residuals as a function of location and time') +
  scale_y_continuous(limits = egg::symmetric_range) 

```

```{r state_categories}

library(zoo)
usa@data %>% 
  select(NAME_1, year, within_between) %>% 
  group_by(NAME_1, within_between) %>% 
  mutate(same_as_previous_year = ifelse(lag(within_between) == within_between,
                                        TRUE,
                                        FALSE),
         year_start = ifelse(is.na(same_as_previous_year),
                             year, NA),
         year_end = ifelse(is.na(lead(same_as_previous_year)),
                                 year, NA),
         year_start = na.locf(year_start),
         year_end = na.locf(year_end),
         year_range = paste(year_start, year_end, sep = '-')) %>% 
  select(within_between, NAME_1, year_range) %>% 
  distinct() %>% 
  arrange(NAME_1) %>% 
  rename(state = NAME_1)

```

